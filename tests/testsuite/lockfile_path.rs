//! Tests for `lockfile-path` flag

use cargo_test_support::paths::CargoPathExt;
use cargo_test_support::{
    basic_bin_manifest, cargo_test, project, symlink_supported, Project, ProjectBuilder,
};
use snapbox::str;
use std::fs;

fn basic_project() -> ProjectBuilder {
    return project()
        .file("Cargo.toml", &basic_bin_manifest("test_foo"))
        .file("src/main.rs", "fn main() {}");
}

fn run_basic_command(p: &Project, command: &str, lockfile_path_argument: &str) {
    p.cargo(command)
        .masquerade_as_nightly_cargo(&["unstable-options"])
        .arg("-Zunstable-options")
        .arg("--lockfile-path")
        .arg(lockfile_path_argument)
        .run();
}

#[track_caller]
fn assert_lockfile_created(command: &str) {
    let lockfile_path_argument = "mylockfile/Cargo.lock";
    let p = basic_project().build();

    for _ in 1..=2 {
        run_basic_command(&p, command, lockfile_path_argument);
        assert!(p.root().join(lockfile_path_argument).is_file());
        assert!(!p.root().join("Cargo.lock").is_file());
    }

    p.root()
        .join(lockfile_path_argument)
        .parent()
        .unwrap()
        .rm_rf();

    run_basic_command(&p, command, lockfile_path_argument);
    assert!(p.root().join(lockfile_path_argument).is_file());
    assert!(!p.root().join("Cargo.lock").is_file());
}

fn assert_embed(command: &str) {
    let lockfile_path_argument = "mylockfile/Cargo.lock";
    let embed = r#"#!/usr/bin/env cargo

//! ```cargo
//! [dependencies]
//! clap = { version = "4.2", features = ["derive"] }
//! ```

use clap::Parser;

#[derive(Parser, Debug)]
#[clap(version)]
struct Args {
    #[clap(short, long, help = "Path to config")]
    config: Option<std::path::PathBuf>,
}

fn main() {
    let args = Args::parse();
    println!("{:?}", args);
}"#;
    let p = project()
        .file("src/main.rs", &embed)
        .build();

    p.cargo(command)
        .masquerade_as_nightly_cargo(&["unstable-options"])
        .arg("-Zunstable-options")
        .arg("--lockfile-path")
        .arg(lockfile_path_argument)
        .arg("--manifest-path")
        .arg("src/main.rs")
        .arg("-Zscript")
        .run();

    assert!(p.root().join(lockfile_path_argument).is_file());
    assert!(!p.root().join("Cargo.lock").is_file());
}

fn assert_lockfile_override(command: &str) {
    let lockfile_path_argument = "mylockfile/Cargo.lock";
    let p = basic_project()
        .file("Cargo.lock", "This is an invalid lock file!")
        .build();

    run_basic_command(&p, command, lockfile_path_argument);

    assert!(p.root().join(lockfile_path_argument).is_file());
}

fn assert_symlink_in_path(command: &str) {
    if !symlink_supported() {
        return;
    }

    let dst = "dst";
    let src = "somedir/link";
    let lockfile_path_argument = format!("{src}/Cargo.lock");

    let p = basic_project().symlink_dir(dst, src).build();

    fs::create_dir(p.root().join("dst"))
        .unwrap_or_else(|e| panic!("could not create directory {}", e));
    assert!(p.root().join(src).is_dir());

    run_basic_command(&p, command, lockfile_path_argument.as_str());

    assert!(p.root().join(format!("{src}/Cargo.lock")).is_file());
    assert!(p.root().join(lockfile_path_argument).is_file());
    assert!(p.root().join(dst).join("Cargo.lock").is_file());
}

fn assert_symlink_lockfile(command: &str) {
    if !symlink_supported() {
        return;
    }

    let lockfile_path_argument = "dst/Cargo.lock";
    let src = "somedir/link";
    let lock_body = r#"# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "test_foo"
version = "0.5.0"
"#;

    let p = basic_project()
        .file(lockfile_path_argument, lock_body)
        .symlink(lockfile_path_argument, src)
        .build();

    assert!(p.root().join(src).is_file());

    run_basic_command(&p, command, lockfile_path_argument);

    assert!(!p.root().join("Cargo.lock").is_file());
}

fn assert_broken_symlink(command: &str) {
    if !symlink_supported() {
        return;
    }

    let invalid_dst = "invalid_path";
    let src = "somedir/link";
    let lockfile_path_argument = format!("{src}/Cargo.lock");

    let p = basic_project().symlink_dir(invalid_dst, src).build();
    assert!(!p.root().join(src).is_dir());

    p.cargo(command)
        .masquerade_as_nightly_cargo(&["unstable-options"])
        .arg("-Zunstable-options")
        .arg("--lockfile-path")
        .arg(lockfile_path_argument)
        .with_status(101)
        .with_stderr_data(str![[r#"
[ERROR] Failed to create lockfile-path parent directory somedir/link

Caused by:
  File exists (os error 17)

"#]])
        .run();
}

fn assert_loop_symlink(command: &str) {
    if !symlink_supported() {
        return;
    }

    let loop_link = "loop";
    let src = "somedir/link";
    let lockfile_path_argument = format!("{src}/Cargo.lock");

    let p = basic_project()
        .symlink_dir(loop_link, src)
        .symlink_dir(src, loop_link)
        .build();
    assert!(!p.root().join(src).is_dir());

    p.cargo(command)
        .masquerade_as_nightly_cargo(&["unstable-options"])
        .arg("-Zunstable-options")
        .arg("--lockfile-path")
        .arg(lockfile_path_argument)
        .with_status(101)
        .with_stderr_data(str![[r#"
[ERROR] Failed to fetch lock file's parent path metadata somedir/link

Caused by:
  Too many levels of symbolic links (os error 40)

"#]])
        .run();
}

#[cargo_test(nightly, reason = "--lockfile-path is unstable")]
fn metadata_lockfile_created() {
    assert_lockfile_created("metadata");
}

#[cargo_test(nightly, reason = "--lockfile-path is unstable")]
fn metadata_embed() {
    assert_embed("metadata");
}

#[cargo_test(nightly, reason = "--lockfile-path is unstable")]
fn metadata_lockfile_override() {
    assert_lockfile_override("metadata");
}

#[cargo_test(nightly, reason = "--lockfile-path is unstable")]
fn metadata_symlink_in_path() {
    assert_symlink_in_path("metadata");
}

#[cargo_test(nightly, reason = "--lockfile-path is unstable")]
fn metadata_symlink_lockfile() {
    assert_symlink_lockfile("metadata");
}

#[cargo_test(nightly, reason = "--lockfile-path is unstable")]
fn metadata_broken_symlink() {
    assert_broken_symlink("metadata");
}

#[cargo_test(nightly, reason = "--lockfile-path is unstable")]
fn metadata_loop_symlink() {
    assert_loop_symlink("metadata");
}
